#   Copyright (C) 2013-2014 Computer Sciences Corporation
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class GaugeThrift(object):
  """
  Attributes:
   - value
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
    (2, TType.STRING, 'error', None, None, ), # 2
  )

  def __init__(self, value=None, error=None,):
    self.value = value
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.error = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GaugeThrift')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRING, 2)
      oprot.writeString(self.error)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CounterThrift(object):
  """
  Attributes:
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'count', None, None, ), # 1
  )

  def __init__(self, count=None,):
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CounterThrift')
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 1)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.count is None:
      raise TProtocol.TProtocolException(message='Required field count is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SnapShotThrift(object):
  """
  Attributes:
   - max
   - min
   - mean
   - median
   - StdDev
   - p75
   - p95
   - p98
   - p99
   - p999
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'max', None, None, ), # 1
    (2, TType.I64, 'min', None, None, ), # 2
    (3, TType.DOUBLE, 'mean', None, None, ), # 3
    (4, TType.DOUBLE, 'median', None, None, ), # 4
    (5, TType.DOUBLE, 'StdDev', None, None, ), # 5
    (6, TType.DOUBLE, 'p75', None, None, ), # 6
    (7, TType.DOUBLE, 'p95', None, None, ), # 7
    (8, TType.DOUBLE, 'p98', None, None, ), # 8
    (9, TType.DOUBLE, 'p99', None, None, ), # 9
    (10, TType.DOUBLE, 'p999', None, None, ), # 10
    (11, TType.LIST, 'values', (TType.I64,None), None, ), # 11
  )

  def __init__(self, max=None, min=None, mean=None, median=None, StdDev=None, p75=None, p95=None, p98=None, p99=None, p999=None, values=None,):
    self.max = max
    self.min = min
    self.mean = mean
    self.median = median
    self.StdDev = StdDev
    self.p75 = p75
    self.p95 = p95
    self.p98 = p98
    self.p99 = p99
    self.p999 = p999
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.max = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.min = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.mean = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.median = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.StdDev = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.p75 = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.p95 = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.p98 = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.DOUBLE:
          self.p99 = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.DOUBLE:
          self.p999 = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.values = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI64();
            self.values.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SnapShotThrift')
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I64, 1)
      oprot.writeI64(self.max)
      oprot.writeFieldEnd()
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I64, 2)
      oprot.writeI64(self.min)
      oprot.writeFieldEnd()
    if self.mean is not None:
      oprot.writeFieldBegin('mean', TType.DOUBLE, 3)
      oprot.writeDouble(self.mean)
      oprot.writeFieldEnd()
    if self.median is not None:
      oprot.writeFieldBegin('median', TType.DOUBLE, 4)
      oprot.writeDouble(self.median)
      oprot.writeFieldEnd()
    if self.StdDev is not None:
      oprot.writeFieldBegin('StdDev', TType.DOUBLE, 5)
      oprot.writeDouble(self.StdDev)
      oprot.writeFieldEnd()
    if self.p75 is not None:
      oprot.writeFieldBegin('p75', TType.DOUBLE, 6)
      oprot.writeDouble(self.p75)
      oprot.writeFieldEnd()
    if self.p95 is not None:
      oprot.writeFieldBegin('p95', TType.DOUBLE, 7)
      oprot.writeDouble(self.p95)
      oprot.writeFieldEnd()
    if self.p98 is not None:
      oprot.writeFieldBegin('p98', TType.DOUBLE, 8)
      oprot.writeDouble(self.p98)
      oprot.writeFieldEnd()
    if self.p99 is not None:
      oprot.writeFieldBegin('p99', TType.DOUBLE, 9)
      oprot.writeDouble(self.p99)
      oprot.writeFieldEnd()
    if self.p999 is not None:
      oprot.writeFieldBegin('p999', TType.DOUBLE, 10)
      oprot.writeDouble(self.p999)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 11)
      oprot.writeListBegin(TType.I64, len(self.values))
      for iter6 in self.values:
        oprot.writeI64(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.max is None:
      raise TProtocol.TProtocolException(message='Required field max is unset!')
    if self.min is None:
      raise TProtocol.TProtocolException(message='Required field min is unset!')
    if self.mean is None:
      raise TProtocol.TProtocolException(message='Required field mean is unset!')
    if self.median is None:
      raise TProtocol.TProtocolException(message='Required field median is unset!')
    if self.StdDev is None:
      raise TProtocol.TProtocolException(message='Required field StdDev is unset!')
    if self.p75 is None:
      raise TProtocol.TProtocolException(message='Required field p75 is unset!')
    if self.p95 is None:
      raise TProtocol.TProtocolException(message='Required field p95 is unset!')
    if self.p98 is None:
      raise TProtocol.TProtocolException(message='Required field p98 is unset!')
    if self.p99 is None:
      raise TProtocol.TProtocolException(message='Required field p99 is unset!')
    if self.p999 is None:
      raise TProtocol.TProtocolException(message='Required field p999 is unset!')
    if self.values is None:
      raise TProtocol.TProtocolException(message='Required field values is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HistogramThrift(object):
  """
  Attributes:
   - count
   - snapshot
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'count', None, None, ), # 1
    (2, TType.STRUCT, 'snapshot', (SnapShotThrift, SnapShotThrift.thrift_spec), None, ), # 2
  )

  def __init__(self, count=None, snapshot=None,):
    self.count = count
    self.snapshot = snapshot

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.snapshot = SnapShotThrift()
          self.snapshot.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HistogramThrift')
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 1)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    if self.snapshot is not None:
      oprot.writeFieldBegin('snapshot', TType.STRUCT, 2)
      self.snapshot.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.count is None:
      raise TProtocol.TProtocolException(message='Required field count is unset!')
    if self.snapshot is None:
      raise TProtocol.TProtocolException(message='Required field snapshot is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MeteredThrift(object):
  """
  Attributes:
   - count
   - m15Rate
   - m5Rate
   - m1Rate
   - meanRate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'count', None, None, ), # 1
    (2, TType.DOUBLE, 'm15Rate', None, None, ), # 2
    (3, TType.DOUBLE, 'm5Rate', None, None, ), # 3
    (4, TType.DOUBLE, 'm1Rate', None, None, ), # 4
    (5, TType.DOUBLE, 'meanRate', None, None, ), # 5
  )

  def __init__(self, count=None, m15Rate=None, m5Rate=None, m1Rate=None, meanRate=None,):
    self.count = count
    self.m15Rate = m15Rate
    self.m5Rate = m5Rate
    self.m1Rate = m1Rate
    self.meanRate = meanRate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.m15Rate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.m5Rate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.m1Rate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.meanRate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MeteredThrift')
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 1)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    if self.m15Rate is not None:
      oprot.writeFieldBegin('m15Rate', TType.DOUBLE, 2)
      oprot.writeDouble(self.m15Rate)
      oprot.writeFieldEnd()
    if self.m5Rate is not None:
      oprot.writeFieldBegin('m5Rate', TType.DOUBLE, 3)
      oprot.writeDouble(self.m5Rate)
      oprot.writeFieldEnd()
    if self.m1Rate is not None:
      oprot.writeFieldBegin('m1Rate', TType.DOUBLE, 4)
      oprot.writeDouble(self.m1Rate)
      oprot.writeFieldEnd()
    if self.meanRate is not None:
      oprot.writeFieldBegin('meanRate', TType.DOUBLE, 5)
      oprot.writeDouble(self.meanRate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.count is None:
      raise TProtocol.TProtocolException(message='Required field count is unset!')
    if self.m15Rate is None:
      raise TProtocol.TProtocolException(message='Required field m15Rate is unset!')
    if self.m5Rate is None:
      raise TProtocol.TProtocolException(message='Required field m5Rate is unset!')
    if self.m1Rate is None:
      raise TProtocol.TProtocolException(message='Required field m1Rate is unset!')
    if self.meanRate is None:
      raise TProtocol.TProtocolException(message='Required field meanRate is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimerThrift(object):
  """
  Attributes:
   - count
   - snapshot
   - meter
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'count', None, None, ), # 1
    (2, TType.STRUCT, 'snapshot', (SnapShotThrift, SnapShotThrift.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'meter', (MeteredThrift, MeteredThrift.thrift_spec), None, ), # 3
  )

  def __init__(self, count=None, snapshot=None, meter=None,):
    self.count = count
    self.snapshot = snapshot
    self.meter = meter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.snapshot = SnapShotThrift()
          self.snapshot.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.meter = MeteredThrift()
          self.meter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimerThrift')
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 1)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    if self.snapshot is not None:
      oprot.writeFieldBegin('snapshot', TType.STRUCT, 2)
      self.snapshot.write(oprot)
      oprot.writeFieldEnd()
    if self.meter is not None:
      oprot.writeFieldBegin('meter', TType.STRUCT, 3)
      self.meter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.count is None:
      raise TProtocol.TProtocolException(message='Required field count is unset!')
    if self.snapshot is None:
      raise TProtocol.TProtocolException(message='Required field snapshot is unset!')
    if self.meter is None:
      raise TProtocol.TProtocolException(message='Required field meter is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetricRegistryThrift(object):
  """
  Attributes:
   - gauges
   - counters
   - histograms
   - meters
   - timers
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'gauges', (TType.STRING,None,TType.STRUCT,(GaugeThrift, GaugeThrift.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'counters', (TType.STRING,None,TType.STRUCT,(CounterThrift, CounterThrift.thrift_spec)), None, ), # 2
    (3, TType.MAP, 'histograms', (TType.STRING,None,TType.STRUCT,(HistogramThrift, HistogramThrift.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'meters', (TType.STRING,None,TType.STRUCT,(MeteredThrift, MeteredThrift.thrift_spec)), None, ), # 4
    (5, TType.MAP, 'timers', (TType.STRING,None,TType.STRUCT,(TimerThrift, TimerThrift.thrift_spec)), None, ), # 5
  )

  def __init__(self, gauges=None, counters=None, histograms=None, meters=None, timers=None,):
    self.gauges = gauges
    self.counters = counters
    self.histograms = histograms
    self.meters = meters
    self.timers = timers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.gauges = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = GaugeThrift()
            _val13.read(iprot)
            self.gauges[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.counters = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin()
          for _i18 in xrange(_size14):
            _key19 = iprot.readString();
            _val20 = CounterThrift()
            _val20.read(iprot)
            self.counters[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.histograms = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin()
          for _i25 in xrange(_size21):
            _key26 = iprot.readString();
            _val27 = HistogramThrift()
            _val27.read(iprot)
            self.histograms[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.meters = {}
          (_ktype29, _vtype30, _size28 ) = iprot.readMapBegin()
          for _i32 in xrange(_size28):
            _key33 = iprot.readString();
            _val34 = MeteredThrift()
            _val34.read(iprot)
            self.meters[_key33] = _val34
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.timers = {}
          (_ktype36, _vtype37, _size35 ) = iprot.readMapBegin()
          for _i39 in xrange(_size35):
            _key40 = iprot.readString();
            _val41 = TimerThrift()
            _val41.read(iprot)
            self.timers[_key40] = _val41
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetricRegistryThrift')
    if self.gauges is not None:
      oprot.writeFieldBegin('gauges', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.gauges))
      for kiter42,viter43 in self.gauges.items():
        oprot.writeString(kiter42)
        viter43.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.counters is not None:
      oprot.writeFieldBegin('counters', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.counters))
      for kiter44,viter45 in self.counters.items():
        oprot.writeString(kiter44)
        viter45.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.histograms is not None:
      oprot.writeFieldBegin('histograms', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.histograms))
      for kiter46,viter47 in self.histograms.items():
        oprot.writeString(kiter46)
        viter47.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.meters is not None:
      oprot.writeFieldBegin('meters', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.meters))
      for kiter48,viter49 in self.meters.items():
        oprot.writeString(kiter48)
        viter49.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.timers is not None:
      oprot.writeFieldBegin('timers', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.timers))
      for kiter50,viter51 in self.timers.items():
        oprot.writeString(kiter50)
        viter51.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.gauges is None:
      raise TProtocol.TProtocolException(message='Required field gauges is unset!')
    if self.counters is None:
      raise TProtocol.TProtocolException(message='Required field counters is unset!')
    if self.histograms is None:
      raise TProtocol.TProtocolException(message='Required field histograms is unset!')
    if self.meters is None:
      raise TProtocol.TProtocolException(message='Required field meters is unset!')
    if self.timers is None:
      raise TProtocol.TProtocolException(message='Required field timers is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
