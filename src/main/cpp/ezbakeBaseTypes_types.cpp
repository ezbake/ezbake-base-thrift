/*   Copyright (C) 2013-2014 Computer Sciences Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. */

/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ezbakeBaseTypes_types.h"

#include <algorithm>

namespace ezbake { namespace base { namespace thrift {

int _kTokenTypeValues[] = {
  TokenType::USER,
  TokenType::APP
};
const char* _kTokenTypeNames[] = {
  "USER",
  "APP"
};
const std::map<int, const char*> _TokenType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTokenTypeValues, _kTokenTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEzSecurityTokenExceptionTypeValues[] = {
  EzSecurityTokenExceptionType::EXPIRED,
  EzSecurityTokenExceptionType::INVALID_SIGNATURE,
  EzSecurityTokenExceptionType::INVALID_SECURITY_ID
};
const char* _kEzSecurityTokenExceptionTypeNames[] = {
  "EXPIRED",
  "INVALID_SIGNATURE",
  "INVALID_SECURITY_ID"
};
const std::map<int, const char*> _EzSecurityTokenExceptionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kEzSecurityTokenExceptionTypeValues, _kEzSecurityTokenExceptionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TimeZone::ascii_fingerprint = "9BC65F3FBD643A502A826C0528CB5B4B";
const uint8_t TimeZone::binary_fingerprint[16] = {0x9B,0xC6,0x5F,0x3F,0xBD,0x64,0x3A,0x50,0x2A,0x82,0x6C,0x05,0x28,0xCB,0x5B,0x4B};

uint32_t TimeZone::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hour = false;
  bool isset_minute = false;
  bool isset_afterUTC = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->hour);
          isset_hour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->minute);
          isset_minute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->afterUTC);
          isset_afterUTC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hour)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_minute)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_afterUTC)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimeZone::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TimeZone");

  xfer += oprot->writeFieldBegin("hour", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->hour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minute", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->minute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("afterUTC", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->afterUTC);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimeZone &a, TimeZone &b) {
  using ::std::swap;
  swap(a.hour, b.hour);
  swap(a.minute, b.minute);
  swap(a.afterUTC, b.afterUTC);
}

const char* Time::ascii_fingerprint = "B127D35BBFA1DCB4BAD357C623BA114D";
const uint8_t Time::binary_fingerprint[16] = {0xB1,0x27,0xD3,0x5B,0xBF,0xA1,0xDC,0xB4,0xBA,0xD3,0x57,0xC6,0x23,0xBA,0x11,0x4D};

uint32_t Time::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hour = false;
  bool isset_minute = false;
  bool isset_tz = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->hour);
          isset_hour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->minute);
          isset_minute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->second);
          this->__isset.second = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->millisecond);
          this->__isset.millisecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tz.read(iprot);
          isset_tz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hour)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_minute)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tz)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Time::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Time");

  xfer += oprot->writeFieldBegin("hour", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->hour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minute", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->minute);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.second) {
    xfer += oprot->writeFieldBegin("second", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->second);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.millisecond) {
    xfer += oprot->writeFieldBegin("millisecond", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->millisecond);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("tz", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->tz.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Time &a, Time &b) {
  using ::std::swap;
  swap(a.hour, b.hour);
  swap(a.minute, b.minute);
  swap(a.second, b.second);
  swap(a.millisecond, b.millisecond);
  swap(a.tz, b.tz);
  swap(a.__isset, b.__isset);
}

const char* Date::ascii_fingerprint = "EEBEE5F2DAE75B1AB615147C163DCA93";
const uint8_t Date::binary_fingerprint[16] = {0xEE,0xBE,0xE5,0xF2,0xDA,0xE7,0x5B,0x1A,0xB6,0x15,0x14,0x7C,0x16,0x3D,0xCA,0x93};

uint32_t Date::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_month = false;
  bool isset_day = false;
  bool isset_year = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->month);
          isset_month = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->day);
          isset_day = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->year);
          isset_year = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_month)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_day)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_year)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Date::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Date");

  xfer += oprot->writeFieldBegin("month", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->month);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("day", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->day);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("year", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->year);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Date &a, Date &b) {
  using ::std::swap;
  swap(a.month, b.month);
  swap(a.day, b.day);
  swap(a.year, b.year);
}

const char* DateTime::ascii_fingerprint = "077BD8E8ABB40ADA1F0C453A0D9C6318";
const uint8_t DateTime::binary_fingerprint[16] = {0x07,0x7B,0xD8,0xE8,0xAB,0xB4,0x0A,0xDA,0x1F,0x0C,0x45,0x3A,0x0D,0x9C,0x63,0x18};

uint32_t DateTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_date = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->date.read(iprot);
          isset_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->time.read(iprot);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_date)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DateTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DateTime");

  xfer += oprot->writeFieldBegin("date", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->date.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DateTime &a, DateTime &b) {
  using ::std::swap;
  swap(a.date, b.date);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

const char* Coordinate::ascii_fingerprint = "EA2086D2BB14222991D7B0497DE7B58B";
const uint8_t Coordinate::binary_fingerprint[16] = {0xEA,0x20,0x86,0xD2,0xBB,0x14,0x22,0x29,0x91,0xD7,0xB0,0x49,0x7D,0xE7,0xB5,0x8B};

uint32_t Coordinate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_latitude = false;
  bool isset_longitude = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->latitude);
          isset_latitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->longitude);
          isset_longitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_latitude)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_longitude)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Coordinate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Coordinate");

  xfer += oprot->writeFieldBegin("latitude", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->latitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("longitude", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->longitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Coordinate &a, Coordinate &b) {
  using ::std::swap;
  swap(a.latitude, b.latitude);
  swap(a.longitude, b.longitude);
}

const char* Preview::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t Preview::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t Preview::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_mimetype = false;
  bool isset_content = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mimetype);
          isset_mimetype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->content);
          isset_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_mimetype)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_content)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Preview::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Preview");

  xfer += oprot->writeFieldBegin("mimetype", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mimetype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Preview &a, Preview &b) {
  using ::std::swap;
  swap(a.mimetype, b.mimetype);
  swap(a.content, b.content);
}

const char* EnterpriseMetaData::ascii_fingerprint = "5EA2D527ECA3BA20C77AFC023EE8C05F";
const uint8_t EnterpriseMetaData::binary_fingerprint[16] = {0x5E,0xA2,0xD5,0x27,0xEC,0xA3,0xBA,0x20,0xC7,0x7A,0xFC,0x02,0x3E,0xE8,0xC0,0x5F};

uint32_t EnterpriseMetaData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tags.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              std::string& _val6 = this->tags[_key5];
              xfer += iprot->readString(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnterpriseMetaData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EnterpriseMetaData");

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tags.size()));
    std::map<std::string, std::string> ::const_iterator _iter7;
    for (_iter7 = this->tags.begin(); _iter7 != this->tags.end(); ++_iter7)
    {
      xfer += oprot->writeString(_iter7->first);
      xfer += oprot->writeString(_iter7->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnterpriseMetaData &a, EnterpriseMetaData &b) {
  using ::std::swap;
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

const char* SSR::ascii_fingerprint = "ED391A21CC64F4C1A7963CCCE3A81453";
const uint8_t SSR::binary_fingerprint[16] = {0xED,0x39,0x1A,0x21,0xCC,0x64,0xF4,0xC1,0xA7,0x96,0x3C,0xCC,0xE3,0xA8,0x14,0x53};

uint32_t SSR::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uri = false;
  bool isset_visibility = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          isset_uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->visibility.read(iprot);
          isset_visibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snippet);
          this->__isset.snippet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resultDate.read(iprot);
          this->__isset.resultDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->coordinate.read(iprot);
          this->__isset.coordinate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->preview.read(iprot);
          this->__isset.preview = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metaData.read(iprot);
          this->__isset.metaData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uri)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_visibility)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SSR::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SSR");

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visibility", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->visibility.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snippet) {
    xfer += oprot->writeFieldBegin("snippet", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->snippet);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resultDate) {
    xfer += oprot->writeFieldBegin("resultDate", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->resultDate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.coordinate) {
    xfer += oprot->writeFieldBegin("coordinate", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->coordinate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.preview) {
    xfer += oprot->writeFieldBegin("preview", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->preview.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metaData) {
    xfer += oprot->writeFieldBegin("metaData", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->metaData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SSR &a, SSR &b) {
  using ::std::swap;
  swap(a.uri, b.uri);
  swap(a.visibility, b.visibility);
  swap(a.title, b.title);
  swap(a.snippet, b.snippet);
  swap(a.resultDate, b.resultDate);
  swap(a.coordinate, b.coordinate);
  swap(a.preview, b.preview);
  swap(a.metaData, b.metaData);
  swap(a.__isset, b.__isset);
}

const char* UserInfo::ascii_fingerprint = "7834815640C7B43F8954B5D3CE5DDC2B";
const uint8_t UserInfo::binary_fingerprint[16] = {0x78,0x34,0x81,0x56,0x40,0xC7,0xB4,0x3F,0x89,0x54,0xB5,0xD3,0xCE,0x5D,0xDC,0x2B};

uint32_t UserInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principal = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal);
          isset_principal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->firstName);
          this->__isset.firstName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lastName);
          this->__isset.lastName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->citizenship);
          this->__isset.citizenship = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->emails.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _ktype9;
            ::apache::thrift::protocol::TType _vtype10;
            xfer += iprot->readMapBegin(_ktype9, _vtype10, _size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              std::string _key13;
              xfer += iprot->readString(_key13);
              std::string& _val14 = this->emails[_key13];
              xfer += iprot->readString(_val14);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.emails = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->phoneNumbers.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _ktype16;
            ::apache::thrift::protocol::TType _vtype17;
            xfer += iprot->readMapBegin(_ktype16, _vtype17, _size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              std::string _key20;
              xfer += iprot->readString(_key20);
              std::string& _val21 = this->phoneNumbers[_key20];
              xfer += iprot->readString(_val21);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.phoneNumbers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->company);
          this->__isset.company = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->organization);
          this->__isset.organization = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principal)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UserInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UserInfo");

  xfer += oprot->writeFieldBegin("principal", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->principal);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.firstName) {
    xfer += oprot->writeFieldBegin("firstName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->firstName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastName) {
    xfer += oprot->writeFieldBegin("lastName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->lastName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.citizenship) {
    xfer += oprot->writeFieldBegin("citizenship", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->citizenship);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.emails) {
    xfer += oprot->writeFieldBegin("emails", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->emails.size()));
      std::map<std::string, std::string> ::const_iterator _iter22;
      for (_iter22 = this->emails.begin(); _iter22 != this->emails.end(); ++_iter22)
      {
        xfer += oprot->writeString(_iter22->first);
        xfer += oprot->writeString(_iter22->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.phoneNumbers) {
    xfer += oprot->writeFieldBegin("phoneNumbers", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->phoneNumbers.size()));
      std::map<std::string, std::string> ::const_iterator _iter23;
      for (_iter23 = this->phoneNumbers.begin(); _iter23 != this->phoneNumbers.end(); ++_iter23)
      {
        xfer += oprot->writeString(_iter23->first);
        xfer += oprot->writeString(_iter23->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.company) {
    xfer += oprot->writeFieldBegin("company", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->company);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.organization) {
    xfer += oprot->writeFieldBegin("organization", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->organization);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserInfo &a, UserInfo &b) {
  using ::std::swap;
  swap(a.principal, b.principal);
  swap(a.id, b.id);
  swap(a.firstName, b.firstName);
  swap(a.lastName, b.lastName);
  swap(a.name, b.name);
  swap(a.citizenship, b.citizenship);
  swap(a.emails, b.emails);
  swap(a.phoneNumbers, b.phoneNumbers);
  swap(a.company, b.company);
  swap(a.organization, b.organization);
  swap(a.__isset, b.__isset);
}

const char* AppInfo::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t AppInfo::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t AppInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_securityId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->securityId);
          isset_securityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal);
          this->__isset.principal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_securityId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AppInfo");

  xfer += oprot->writeFieldBegin("securityId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->securityId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.principal) {
    xfer += oprot->writeFieldBegin("principal", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->principal);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppInfo &a, AppInfo &b) {
  using ::std::swap;
  swap(a.securityId, b.securityId);
  swap(a.principal, b.principal);
  swap(a.__isset, b.__isset);
}

const char* CommunityMembership::ascii_fingerprint = "B279875DD7F3025703CE55AE62476533";
const uint8_t CommunityMembership::binary_fingerprint[16] = {0xB2,0x79,0x87,0x5D,0xD7,0xF3,0x02,0x57,0x03,0xCE,0x55,0xAE,0x62,0x47,0x65,0x33};

uint32_t CommunityMembership::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->organization);
          this->__isset.organization = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groups.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->groups.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += iprot->readString(this->groups[_i28]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->regions.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->regions.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readString(this->regions[_i33]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.regions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topics.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->topics.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += iprot->readString(this->topics[_i38]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.topics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _ktype40;
            ::apache::thrift::protocol::TType _vtype41;
            xfer += iprot->readMapBegin(_ktype40, _vtype41, _size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              std::string _key44;
              xfer += iprot->readString(_key44);
              bool& _val45 = this->flags[_key44];
              xfer += iprot->readBool(_val45);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommunityMembership::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CommunityMembership");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.organization) {
    xfer += oprot->writeFieldBegin("organization", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->organization);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groups) {
    xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->groups.size()));
      std::vector<std::string> ::const_iterator _iter46;
      for (_iter46 = this->groups.begin(); _iter46 != this->groups.end(); ++_iter46)
      {
        xfer += oprot->writeString((*_iter46));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.regions) {
    xfer += oprot->writeFieldBegin("regions", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->regions.size()));
      std::vector<std::string> ::const_iterator _iter47;
      for (_iter47 = this->regions.begin(); _iter47 != this->regions.end(); ++_iter47)
      {
        xfer += oprot->writeString((*_iter47));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.topics) {
    xfer += oprot->writeFieldBegin("topics", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->topics.size()));
      std::vector<std::string> ::const_iterator _iter48;
      for (_iter48 = this->topics.begin(); _iter48 != this->topics.end(); ++_iter48)
      {
        xfer += oprot->writeString((*_iter48));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
      std::map<std::string, bool> ::const_iterator _iter49;
      for (_iter49 = this->flags.begin(); _iter49 != this->flags.end(); ++_iter49)
      {
        xfer += oprot->writeString(_iter49->first);
        xfer += oprot->writeBool(_iter49->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommunityMembership &a, CommunityMembership &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.organization, b.organization);
  swap(a.groups, b.groups);
  swap(a.regions, b.regions);
  swap(a.topics, b.topics);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

const char* ValidityCaveats::ascii_fingerprint = "25223CBE1B43DC5C64F041B3759C651E";
const uint8_t ValidityCaveats::binary_fingerprint[16] = {0x25,0x22,0x3C,0xBE,0x1B,0x43,0xDC,0x5C,0x64,0xF0,0x41,0xB3,0x75,0x9C,0x65,0x1E};

uint32_t ValidityCaveats::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_issuer = false;
  bool isset_issuedTo = false;
  bool isset_notAfter = false;
  bool isset_signature = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->issuer);
          isset_issuer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->issuedTo);
          isset_issuedTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->issuedFor);
          this->__isset.issuedFor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->issuedTime);
          this->__isset.issuedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->notBefore);
          this->__isset.notBefore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->notAfter);
          isset_notAfter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          isset_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_issuer)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_issuedTo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_notAfter)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_signature)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ValidityCaveats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ValidityCaveats");

  xfer += oprot->writeFieldBegin("issuer", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->issuer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("issuedTo", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->issuedTo);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.issuedFor) {
    xfer += oprot->writeFieldBegin("issuedFor", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->issuedFor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.issuedTime) {
    xfer += oprot->writeFieldBegin("issuedTime", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->issuedTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notBefore) {
    xfer += oprot->writeFieldBegin("notBefore", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->notBefore);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("notAfter", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->notAfter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ValidityCaveats &a, ValidityCaveats &b) {
  using ::std::swap;
  swap(a.issuer, b.issuer);
  swap(a.issuedTo, b.issuedTo);
  swap(a.issuedFor, b.issuedFor);
  swap(a.issuedTime, b.issuedTime);
  swap(a.notBefore, b.notBefore);
  swap(a.notAfter, b.notAfter);
  swap(a.signature, b.signature);
  swap(a.__isset, b.__isset);
}

const char* EzSecurityPrincipal::ascii_fingerprint = "9B6BB2DAECC6391CE68DBB794DC5F1CD";
const uint8_t EzSecurityPrincipal::binary_fingerprint[16] = {0x9B,0x6B,0xB2,0xDA,0xEC,0xC6,0x39,0x1C,0xE6,0x8D,0xBB,0x79,0x4D,0xC5,0xF1,0xCD};

uint32_t EzSecurityPrincipal::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principal = false;
  bool isset_validity = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal);
          isset_principal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->issuer);
          this->__isset.issuer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->validity.read(iprot);
          isset_validity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requestChain.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readListBegin(_etype53, _size50);
            this->requestChain.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += iprot->readString(this->requestChain[_i54]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requestChain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->externalID);
          this->__isset.externalID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principal)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_validity)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EzSecurityPrincipal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EzSecurityPrincipal");

  xfer += oprot->writeFieldBegin("principal", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->principal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validity", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->validity.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.requestChain) {
    xfer += oprot->writeFieldBegin("requestChain", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requestChain.size()));
      std::vector<std::string> ::const_iterator _iter55;
      for (_iter55 = this->requestChain.begin(); _iter55 != this->requestChain.end(); ++_iter55)
      {
        xfer += oprot->writeString((*_iter55));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.externalID) {
    xfer += oprot->writeFieldBegin("externalID", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->externalID);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.issuer) {
    xfer += oprot->writeFieldBegin("issuer", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->issuer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EzSecurityPrincipal &a, EzSecurityPrincipal &b) {
  using ::std::swap;
  swap(a.principal, b.principal);
  swap(a.issuer, b.issuer);
  swap(a.validity, b.validity);
  swap(a.requestChain, b.requestChain);
  swap(a.externalID, b.externalID);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

const char* EzSecurityToken::ascii_fingerprint = "ECCB78461C724CBC388BFB90FCB05F06";
const uint8_t EzSecurityToken::binary_fingerprint[16] = {0xEC,0xCB,0x78,0x46,0x1C,0x72,0x4C,0xBC,0x38,0x8B,0xFB,0x90,0xFC,0xB0,0x5F,0x06};

uint32_t EzSecurityToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_validity = false;
  bool isset_type = false;
  bool isset_tokenPrincipal = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->validity.read(iprot);
          isset_validity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast56;
          xfer += iprot->readI32(ecast56);
          this->type = (TokenType::type)ecast56;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tokenPrincipal.read(iprot);
          isset_tokenPrincipal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authorizationLevel);
          this->__isset.authorizationLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->externalProjectGroups.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _ktype58;
            ::apache::thrift::protocol::TType _vtype59;
            xfer += iprot->readMapBegin(_ktype58, _vtype59, _size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              std::string _key62;
              xfer += iprot->readString(_key62);
              std::vector<std::string> & _val63 = this->externalProjectGroups[_key62];
              {
                _val63.clear();
                uint32_t _size64;
                ::apache::thrift::protocol::TType _etype67;
                xfer += iprot->readListBegin(_etype67, _size64);
                _val63.resize(_size64);
                uint32_t _i68;
                for (_i68 = 0; _i68 < _size64; ++_i68)
                {
                  xfer += iprot->readString(_val63[_i68]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.externalProjectGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->externalCommunities.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _ktype70;
            ::apache::thrift::protocol::TType _vtype71;
            xfer += iprot->readMapBegin(_ktype70, _vtype71, _size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              std::string _key74;
              xfer += iprot->readString(_key74);
              CommunityMembership& _val75 = this->externalCommunities[_key74];
              xfer += _val75.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.externalCommunities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->citizenship);
          this->__isset.citizenship = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->organization);
          this->__isset.organization = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validForExternalRequest);
          this->__isset.validForExternalRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->externalRequestPrincipal);
          this->__isset.externalRequestPrincipal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->externalRequestPrincipalIssuer);
          this->__isset.externalRequestPrincipalIssuer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_validity)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tokenPrincipal)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EzSecurityToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EzSecurityToken");

  xfer += oprot->writeFieldBegin("validity", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->validity.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokenPrincipal", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tokenPrincipal.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.authorizationLevel) {
    xfer += oprot->writeFieldBegin("authorizationLevel", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->authorizationLevel);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.externalProjectGroups) {
    xfer += oprot->writeFieldBegin("externalProjectGroups", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->externalProjectGroups.size()));
      std::map<std::string, std::vector<std::string> > ::const_iterator _iter76;
      for (_iter76 = this->externalProjectGroups.begin(); _iter76 != this->externalProjectGroups.end(); ++_iter76)
      {
        xfer += oprot->writeString(_iter76->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter76->second.size()));
          std::vector<std::string> ::const_iterator _iter77;
          for (_iter77 = _iter76->second.begin(); _iter77 != _iter76->second.end(); ++_iter77)
          {
            xfer += oprot->writeString((*_iter77));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.externalCommunities) {
    xfer += oprot->writeFieldBegin("externalCommunities", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->externalCommunities.size()));
      std::map<std::string, CommunityMembership> ::const_iterator _iter78;
      for (_iter78 = this->externalCommunities.begin(); _iter78 != this->externalCommunities.end(); ++_iter78)
      {
        xfer += oprot->writeString(_iter78->first);
        xfer += _iter78->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.citizenship) {
    xfer += oprot->writeFieldBegin("citizenship", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->citizenship);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.organization) {
    xfer += oprot->writeFieldBegin("organization", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->organization);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validForExternalRequest) {
    xfer += oprot->writeFieldBegin("validForExternalRequest", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->validForExternalRequest);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.externalRequestPrincipal) {
    xfer += oprot->writeFieldBegin("externalRequestPrincipal", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->externalRequestPrincipal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.externalRequestPrincipalIssuer) {
    xfer += oprot->writeFieldBegin("externalRequestPrincipalIssuer", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->externalRequestPrincipalIssuer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EzSecurityToken &a, EzSecurityToken &b) {
  using ::std::swap;
  swap(a.validity, b.validity);
  swap(a.type, b.type);
  swap(a.tokenPrincipal, b.tokenPrincipal);
  swap(a.authorizationLevel, b.authorizationLevel);
  swap(a.authorizations, b.authorizations);
  swap(a.externalProjectGroups, b.externalProjectGroups);
  swap(a.externalCommunities, b.externalCommunities);
  swap(a.citizenship, b.citizenship);
  swap(a.organization, b.organization);
  swap(a.validForExternalRequest, b.validForExternalRequest);
  swap(a.externalRequestPrincipal, b.externalRequestPrincipal);
  swap(a.externalRequestPrincipalIssuer, b.externalRequestPrincipalIssuer);
  swap(a.__isset, b.__isset);
}

const char* EzSecurityTokenException::ascii_fingerprint = "B33AE596EF78C48424CF96BCA5D1DF99";
const uint8_t EzSecurityTokenException::binary_fingerprint[16] = {0xB3,0x3A,0xE5,0x96,0xEF,0x78,0xC4,0x84,0x24,0xCF,0x96,0xBC,0xA5,0xD1,0xDF,0x99};

uint32_t EzSecurityTokenException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->originalException);
          this->__isset.originalException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast79;
          xfer += iprot->readI32(ecast79);
          this->type = (EzSecurityTokenExceptionType::type)ecast79;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EzSecurityTokenException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EzSecurityTokenException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.originalException) {
    xfer += oprot->writeFieldBegin("originalException", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->originalException);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EzSecurityTokenException &a, EzSecurityTokenException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.originalException, b.originalException);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

const char* EzSecurityTokenJson::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t EzSecurityTokenJson::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t EzSecurityTokenJson::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_json = false;
  bool isset_signature = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->json);
          isset_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          isset_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_json)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_signature)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EzSecurityTokenJson::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EzSecurityTokenJson");

  xfer += oprot->writeFieldBegin("json", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EzSecurityTokenJson &a, EzSecurityTokenJson &b) {
  using ::std::swap;
  swap(a.json, b.json);
  swap(a.signature, b.signature);
}

const char* X509Info::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t X509Info::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t X509Info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_subject = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subject);
          isset_subject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->issuer);
          this->__isset.issuer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_subject)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t X509Info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("X509Info");

  xfer += oprot->writeFieldBegin("subject", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->subject);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.issuer) {
    xfer += oprot->writeFieldBegin("issuer", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->issuer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(X509Info &a, X509Info &b) {
  using ::std::swap;
  swap(a.subject, b.subject);
  swap(a.issuer, b.issuer);
  swap(a.__isset, b.__isset);
}

const char* ProxyUserToken::ascii_fingerprint = "1BBC2511F2299E1B5676E483E228793C";
const uint8_t ProxyUserToken::binary_fingerprint[16] = {0x1B,0xBC,0x25,0x11,0xF2,0x29,0x9E,0x1B,0x56,0x76,0xE4,0x83,0xE2,0x28,0x79,0x3C};

uint32_t ProxyUserToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_issuedBy = false;
  bool isset_issuedTo = false;
  bool isset_notAfter = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->x509.read(iprot);
          this->__isset.x509 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->issuedBy);
          isset_issuedBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->issuedTo);
          isset_issuedTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->issuedFor);
          this->__isset.issuedFor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->notAfter);
          isset_notAfter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->notBefore);
          this->__isset.notBefore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_issuedBy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_issuedTo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_notAfter)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ProxyUserToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ProxyUserToken");

  xfer += oprot->writeFieldBegin("x509", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->x509.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("issuedBy", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->issuedBy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("issuedTo", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->issuedTo);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.issuedFor) {
    xfer += oprot->writeFieldBegin("issuedFor", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->issuedFor);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("notAfter", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->notAfter);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.notBefore) {
    xfer += oprot->writeFieldBegin("notBefore", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->notBefore);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProxyUserToken &a, ProxyUserToken &b) {
  using ::std::swap;
  swap(a.x509, b.x509);
  swap(a.issuedBy, b.issuedBy);
  swap(a.issuedTo, b.issuedTo);
  swap(a.issuedFor, b.issuedFor);
  swap(a.notAfter, b.notAfter);
  swap(a.notBefore, b.notBefore);
  swap(a.__isset, b.__isset);
}

const char* ProxyPrincipal::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t ProxyPrincipal::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t ProxyPrincipal::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_proxyToken = false;
  bool isset_signature = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxyToken);
          isset_proxyToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          isset_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_proxyToken)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_signature)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ProxyPrincipal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ProxyPrincipal");

  xfer += oprot->writeFieldBegin("proxyToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->proxyToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProxyPrincipal &a, ProxyPrincipal &b) {
  using ::std::swap;
  swap(a.proxyToken, b.proxyToken);
  swap(a.signature, b.signature);
}

const char* TokenRequest::ascii_fingerprint = "A05A8BCF2BCCAC58750CCCB1030E41B0";
const uint8_t TokenRequest::binary_fingerprint[16] = {0xA0,0x5A,0x8B,0xCF,0x2B,0xCC,0xAC,0x58,0x75,0x0C,0xCC,0xB1,0x03,0x0E,0x41,0xB0};

uint32_t TokenRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_securityId = false;
  bool isset_timestamp = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->securityId);
          isset_securityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetSecurityId);
          this->__isset.targetSecurityId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast80;
          xfer += iprot->readI32(ecast80);
          this->type = (TokenType::type)ecast80;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->caveats.read(iprot);
          this->__isset.caveats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->proxyPrincipal.read(iprot);
          this->__isset.proxyPrincipal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tokenPrincipal.read(iprot);
          this->__isset.tokenPrincipal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->principal.read(iprot);
          this->__isset.principal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_securityId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TokenRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TokenRequest");

  xfer += oprot->writeFieldBegin("securityId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->securityId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.targetSecurityId) {
    xfer += oprot->writeFieldBegin("targetSecurityId", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->targetSecurityId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.caveats) {
    xfer += oprot->writeFieldBegin("caveats", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->caveats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxyPrincipal) {
    xfer += oprot->writeFieldBegin("proxyPrincipal", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->proxyPrincipal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tokenPrincipal) {
    xfer += oprot->writeFieldBegin("tokenPrincipal", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->tokenPrincipal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.principal) {
    xfer += oprot->writeFieldBegin("principal", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->principal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenRequest &a, TokenRequest &b) {
  using ::std::swap;
  swap(a.securityId, b.securityId);
  swap(a.targetSecurityId, b.targetSecurityId);
  swap(a.timestamp, b.timestamp);
  swap(a.type, b.type);
  swap(a.caveats, b.caveats);
  swap(a.proxyPrincipal, b.proxyPrincipal);
  swap(a.tokenPrincipal, b.tokenPrincipal);
  swap(a.principal, b.principal);
  swap(a.__isset, b.__isset);
}

}}} // namespace
